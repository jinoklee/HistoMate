# Form implementation generated from reading ui file '.\HistoMate.beta01.ui'
#
# Created by: PyQt6 UI code generator 6.1.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import os
import glob
import time
import gc
from multiprocessing import Process, Queue
import multiprocessing
import threading
from concurrent.futures import ThreadPoolExecutor

from tempfile import TemporaryFile
from pathlib import Path

sys.path.append("./common")
sys.path.extend(["../.", "."])

from PyQt5.QtWidgets import *
from PyQt5 import uic
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QHBoxLayout, QProgressBar, QVBoxLayout, QMainWindow, QGraphicsView, QGraphicsScene, QLabel

import openslide
import cv2
from PIL.ImageQt import ImageQt, Image
from PIL import Image
import imageio

import skimage
from skimage import io
from skimage.exposure import match_histograms
from skimage.morphology import remove_small_objects
import numpy as np

import pandas as pd
import scipy.signal
from unet import UNet
import math


from common.tile_processing_parallel import process_tiles
from common.wsi_reader import get_reader_impl

#from segmentationSingle import *

import torch
from torch.utils.data import Dataset
from torchvision import transforms
from torch.utils.data import Dataset
from torchvision import transforms
import torch.nn as nn

from tqdm import tqdm



os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"  # see issue #152
os.environ["CUDA_VISIBLE_DEVICES"] = "0"


class CLAHE(object):
    # histogram equalisation
    def __init__(self):
        self.clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))

    def __call__(self, img):
        HSV = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
        HSV[:, :, 0] = self.clahe.apply(HSV[:, :, 0])
        img = cv2.cvtColor(HSV, cv2.COLOR_HSV2RGB)

        return img

class SegDataset(Dataset):

    def __init__(self, img, patch_size, subdivisions):
        self.img = img
        self.patch_size = patch_size
        self.subdivisions = subdivisions
        self.totensor = transforms.ToTensor()
        self.normalise = transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
        self.histeq = CLAHE()
        self.coordinates = self._extract_patches()

    def _extract_patches(self):
        """
        :param img:
        :return: a generator
        """
        step = int(self.patch_size / self.subdivisions)

        row_range = range(0, self.img.shape[0] - self.patch_size + 1, step)
        col_range = range(0, self.img.shape[1] - self.patch_size + 1, step)

        coordinates = []
        for row in row_range:
            for col in col_range:
                coordinates.append((row, col))

        return coordinates

    def __len__(self):
        return len(self.coordinates)

    def __getitem__(self, idx):
        row, col = self.coordinates[idx]
        image = self.img[row:(row+self.patch_size), col:(col+self.patch_size), :]

        # instance norm
        image = self.histeq(image)

        # scale between 0 and 1 and swap the dimension
        image = self.totensor(image)
        image = self.normalise(image)

        return image

class TilePrediction(object):
    def __init__(self, patch_size, subdivisions, pred_model, batch_size, workers):
        """
        :param patch_size:
        :param subdivisions: the size of stride is define by this
        :param scaling_factor: what factor should prediction model operate on
        :param pred_model: the prediction function
        """
        self.patch_size = patch_size
        self.subdivisions = subdivisions
        self.pred_model = pred_model
        self.batch_size = batch_size
        self.workers = workers

        self.stride = int(self.patch_size / self.subdivisions)

        print("predict00")
        transform_list = [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]
        self.transform = transforms.Compose(transform_list)

        self.WINDOW_SPLINE_2D = self._window_2D(window_size=self.patch_size, effective_window_size=patch_size, power=2)

    def _read_data(self, filename):
        """
        :param filename:
        :return:
        """
        mpp2mag = {.25: 40, .5: 20, 1: 10}
        reader = get_reader_impl(filename)
        slide = reader(filename)

        mpp = 0.25
        wsi_highest_magnification = mpp2mag[.25 * round(float(mpp) / .25)]
        downsample = wsi_highest_magnification / 1.25 #mask_magnification
        slide_level_dimensions = (int(np.round(slide.level_dimensions[0][0] / downsample)),
                                  int(np.round(slide.level_dimensions[0][1] / downsample)))
        img, _ = slide.get_downsampled_slide(slide_level_dimensions, normalize=False)
        img = self._pad_img(img)

        return img

    def _pad_img(self, img):
        """
        Add borders to img for a "valid" border pattern according to "window_size" and
        "subdivisions".
        Image is an np array of shape (x, y, nb_channels).
        """
        aug = int(round(self.patch_size * (1 - 1.0 / self.subdivisions)))
        more_borders = ((aug, aug), (aug, aug), (0, 0))
        ret = np.pad(img, pad_width=more_borders, mode='reflect')

        return ret

    def _unpad_img(self, padded_img):
        """
        Undo what's done in the `_pad_img` function.
        Image is an np array of shape (x, y, nb_channels).
        """
        aug = int(round(self.patch_size * (1 - 1.0 / self.subdivisions)))
        ret = padded_img[aug:-aug, aug:-aug, :]
        return ret

    def _spline_window(self, patch_size, effective_window_size, power=2):
        """
        Squared spline (power=2) window function:
        https://www.wolframalpha.com/input/?i=y%3Dx**2,+y%3D-(x-2)**2+%2B2,+y%3D(x-4)**2,+from+y+%3D+0+to+2
        """
        window_size = effective_window_size
        intersection = int(window_size / 4)
        wind_outer = (abs(2 * (scipy.signal.triang(window_size))) ** power) / 2
        wind_outer[intersection:-intersection] = 0

        wind_inner = 1 - (abs(2 * (scipy.signal.triang(window_size) - 1)) ** power) / 2
        wind_inner[:intersection] = 0
        wind_inner[-intersection:] = 0

        wind = wind_inner + wind_outer
        wind = wind / np.average(wind)

        aug = int(round((patch_size - window_size) / 2.0))
        wind = np.pad(wind, (aug, aug), mode='constant')
        wind = wind[:patch_size]

        return wind

    def _window_2D(self, window_size, effective_window_size, power=2):
        """
        Make a 1D window function, then infer and return a 2D window function.
        Done with an augmentation, and self multiplication with its transpose.
        Could be generalized to more dimensions.
        """
        # Memoization
        wind = self._spline_window(window_size, effective_window_size, power)
        wind = np.expand_dims(np.expand_dims(wind, 1), 2)
        wind = wind * wind.transpose(1, 0, 2)
        return wind

    def _merge_patches(self, patches, padded_img_size):
        """
        :param patches:
        :param padded_img_size:
        :return:
        """
        n_dims = patches[0].shape[-1]
        img = np.zeros([padded_img_size[0], padded_img_size[1], n_dims], dtype=np.float32)

        window_size = self.patch_size
        step = int(window_size / self.subdivisions)

        row_range = range(0, img.shape[0] - self.patch_size + 1, step)
        col_range = range(0, img.shape[1] - self.patch_size + 1, step)

        for index1, row in enumerate(row_range):
            for index2, col in enumerate(col_range):
                tmp = patches[(index1 * len(col_range)) + index2]
                tmp *= self.WINDOW_SPLINE_2D

                img[row:row + self.patch_size, col:col + self.patch_size, :] = \
                    img[row:row + self.patch_size, col:col + self.patch_size, :] + tmp

        img = img / (self.subdivisions ** 2)
        return self._unpad_img(img)

    def batches(self, generator, size):
        """
        :param generator: a generator
        :param size: size of a chunk
        :return:
        """
        source = generator
        while True:
            chunk = [val for _, val in zip(range(size), source)]
            if not chunk:
                raise StopIteration
            yield chunk

    def run(self, filename,savename):
        """
        :param filename:
        :return:
        """
        print("predict0")
        # read image, scaling, and padding
        padded_img = self._read_data(filename)
        print("predict1")
        # extract patches
        test_dataset = SegDataset(padded_img, self.patch_size, self.subdivisions)
        test_loader = torch.utils.data.DataLoader(test_dataset,
                                                   batch_size=self.batch_size,
                                                   num_workers=self.workers,
                                                   shuffle=False)
        gc.collect()
        # run the model in batches
        all_prediction = []
        for patches in tqdm(test_loader):
            if torch.cuda.is_available():
                patches = patches.cuda()

            all_prediction += [self.pred_model(patches).cpu().data.numpy()]
        print("predict2")
        all_prediction = np.concatenate(all_prediction, axis=0)
        all_prediction = all_prediction.transpose(0, 2, 3, 1)

        result = self._merge_patches(all_prediction, padded_img.shape)

        # confidence
        print("predict3")
        result = np.argmax(result, axis=2) * 255.0
        result = result.astype(np.uint8)
        result = np.clip(result, 0, 255).astype(np.uint8)
        segmentation = remove_small_objects(result == 255, 50 ** 2)
        segmentation = (segmentation * 255).astype(np.uint8)
        cv2.imwrite(savename, segmentation)

def NormHist(filename, savename,Target):
    Orig_Image = io.imread(filename)
    Target_Image = io.imread(Target)
    Norm_Image = match_histograms(Orig_Image, Target_Image , channel_axis = -1)
    io.imsave(savename, Norm_Image)


form_class = uic.loadUiType("HistoMate.beta04.ui")[0]
home=os.getenv("HOME")

# Set the paramers: segentation & tiling
slide_id ="*.svs"
tsmodel = "checkpoint_ts.pth"
mpp = 0.25
tile_size =  512 #256
stride = 512 #256
tile_magnification = 20 # 10
mask_magnification = 1.25
mask_ratio = 0.2
ds_level_0 =True
ThreadsAllowed = int(multiprocessing.cpu_count())
##

def getImageThumbnail(filepath):
    slide = openslide.OpenSlide(filepath)
    CanvasWidth = 500
    CanvasHeight = 600
    thumb = slide.get_thumbnail((int(CanvasWidth), int(CanvasHeight)))
    metadf = pd.DataFrame(slide.properties.items())
    return (thumb, metadf)

def save_tile(tile, x_y, wsi_highest_magnification, save_folder, slide_name, tile_magnification):
    x, y = x_y
    savename = os.path.join(save_folder,
     slide_name + f'_obj_{wsi_highest_magnification}x_{tile_magnification}x_x_{x}_y_{y}.png')
    if not os.path.exists(savename):
        imageio.imwrite(savename, np.array(tile))

# load pandas dataframe
class pandasModel(QAbstractTableModel) :
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data

    def rowCount(self, parent=None):
        return self._data.shape[0]

    def columnCount(self, parnet=None):
        return self._data.shape[1]

    def data(self, index, role=Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None

    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None


## Main Window
class WindowClass(QMainWindow, form_class) :
    def __init__(self) :
        super().__init__()
        self.setupUi(self)

        # List Widget => iconMode
        #self.listWidget.setMovement(QListWidget.Static)
        #self.listWidget.setViewMode(QListWidget.IconMode)
        #self.listWidget.setResizeMode(QListWidget.Adjust)
        # self.listView.setSpacing(5)
        #self.listWidget.setContextMenuPolicy(Qt.CustomContextMenu)

        # List Widget_2 => iconMode
        self.listWidget_2.setMovement(QListWidget.Static)
        self.listWidget_2.setViewMode(QListWidget.IconMode)
        self.listWidget_2.setResizeMode(QListWidget.Adjust)
        #self.listWidget_2.setSpacing(5)
       #self.listWidget_2.setContextMenuPolicy(Qt.CustomContextMenu)




        # command test
        self.plainTextEdit.setPlainText("Welcome to HistoMate! Please, click the New Project button")

        # Button -> function
        self.new_project_btn.clicked.connect(self.button1Function) # new project_btn1
        self.load_btn.clicked.connect(self.button2Function) # loading browser_btn2
        self.seg_btn.clicked.connect(self.button3Function) # move to Segmentation_btn3
        self.patch_btn.clicked.connect(self.button4Function) # move to Patching_btn4
        self.nor_btn.clicked.connect(self.button5Function) # move to Normalization_btn5
        self.qc_btn.clicked.connect(self.button6Function) # move to qc_btn6
        self.aug_btn.clicked.connect(self.button7Function) # move to augmentation_btn7
        self.pqc_btn.clicked.connect(self.button8Function)  # move to augmentation_btn7
        self.sum_btn.clicked.connect(self.button9Function) # move to summary_btn8

        # changed text -> function
        self.lineEdit.textChanged.connect(self.set_on_slideDir)
        self.lineEdit_2.textChanged.connect(self.set_on_outputDir)

        # tree model
        self.model_file_system = QFileSystemModel()
        self.model_file_system.setRootPath("")
        self.model_file_system.setReadOnly(False)


        # tree connect ## loading tab
        self.treeView_1.clicked.connect(lambda index : self.item_clikced_1(index)) # (lambda index: self.item_double_clikced(index))

        # tree connect ## segmentation tab
        self.treeView_2.clicked.connect(lambda index : self.item_clikced_2(index)) # (lambda index: self.item_double_clikced(index))

        # tree connect ## patch tab
        self.treeView_3.clicked.connect(lambda index : self.item_clikced_3(index)) # (lambda index: self.item_double_clikced(index))

        # tree connect ## normalization tab
        self.treeView_4.clicked.connect(lambda index: self.item_clikced_4(index))  # (lambda index: self.item_double_clikced(index))

        # tree connect ## augmentation tab
        self.treeView_5.clicked.connect(lambda index: self.item_clikced_5(index))  # (lambda index: self.item_double_clikced(index))

        # tree connect ## slideqc tab
        self.treeView_6.clicked.connect(
            lambda index: self.item_clikced_6(index))  # (lambda index: self.item_double_clikced(index))

        # tree connect ## results patchQC
        self.treeView_7.clicked.connect(
            lambda index: self.item_clikced_7(index))  # (lambda index: self.item_double_clikced(index))

        # tree connect ## results tab
        self.treeView_8.clicked.connect(
            lambda index: self.item_clikced_8(index))  # (lambda index: self.item_double_clikced(index))


        # segmentation
        self.obj = Worker00()
        self.thread = QThread()
        self.obj.moveToThread(self.thread)
        self.thread.started.connect(self.obj.run)
        self.obj.intReady.connect(self.on_text_changed)
        self.obj.finished.connect(self.thread.quit)
        #self.obj.finished.connect(self.button4Function)

        # patching
        self.obj1 = Worker01()
        self.thread1 = QThread()
        self.obj1.moveToThread(self.thread1)
        self.thread1.started.connect(self.obj1.run)
        self.obj1.intReady.connect(self.on_text_changed)
        self.obj1.finished.connect(self.thread1.quit)
        #self.obj1.finished.connect(self.button5Function)

        #self.graphicsView = QGraphicsView(self)
        #self.graphicsView.setFixedSize(800, 800)
        self.graphicsView.setScene(QGraphicsScene(self))
        self.graphicsView.setRenderHint(QPainter.Antialiasing)
        self.graphicsView.setRenderHint(QPainter.SmoothPixmapTransform)

        # 버튼 만들기
        # self.zoom_in_button = QPushButton("+", self)
        # self.zoom_out_button = QPushButton("-", self)

        # 버튼 위치 조정
        # self.label.move(50, 50)
        # self.view.move(500, 50)
        # self.zoom_in_button.move(500, 1000)
        # self.zoom_out_button.move(600, 1000)

        # 버튼 클릭 시 호출할 함수 연결
        self.zoom_in_button.clicked.connect(self.zoom_in)
        self.zoom_out_button.clicked.connect(self.zoom_out)

        # Tiling 이미지 드래그 설정
        self.graphicsView.setDragMode(QGraphicsView.ScrollHandDrag)


        # Normalization
        self.obj2 = Worker02()
        self.thread2 = QThread()
        self.obj2.moveToThread(self.thread2)
        self.thread2.started.connect(self.obj2.run)
        self.obj2.intReady.connect(self.on_text_changed)
        self.obj2.finished.connect(self.thread2.quit)
        #self.obj2.finished.connect(self.button6Function)

        # Augmentation
        self.obj3 = Worker03()
        self.thread3 = QThread()
        self.obj3.moveToThread(self.thread3)
        self.thread3.started.connect(self.obj3.run)
        self.obj3.intReady.connect(self.on_text_changed)
        self.obj3.finished.connect(self.thread3.quit)
        #self.obj3.finished.connect(self.button7Function)

    # Btn1 : set output directory :# new project_btn1
    def button1Function(self):
        global outputDir
        outputDir = QFileDialog.getExistingDirectory(self, "Open Directory", home, # expanduser('./'),
                                                   QFileDialog.ShowDirsOnly)
        #outputDir = "C:/Users/PC/Documents/HistoMate/test"
        self.lineEdit_2.setText("Project output path: "+ outputDir)
        patchFolder = os.path.join(outputDir, "patch")
        qualFolder = patchFolder.replace("patch", "qual")
        maskFolder = patchFolder.replace("patch", "mask")
        pngFolder = patchFolder.replace("patch","png")
        csvFolder = patchFolder.replace("patch", "csv")
        NorFolder = patchFolder.replace("patch", "colNor")
        augFolder = patchFolder.replace("patch", "aug")
        pqcFolder = patchFolder.replace("patch", "patchqc")
        sumFolder = patchFolder.replace("patch", "summary")

        # mkdir sub folders
        for subPath in [qualFolder, patchFolder, maskFolder, pngFolder, csvFolder, NorFolder, augFolder, pqcFolder, sumFolder]:
            if not os.path.exists(subPath):
                os.makedirs(subPath)
        # move to next tab
        print("make folders")
        self.tabWidget.setCurrentIndex(1)
        self.plainTextEdit.appendPlainText("\n....>> Select a folder containing slides to analyze.")

    # Btn2: set the path for loading slides :# loading browser_btn2
    def button2Function(self):
        global slideDir
        slideDir = QFileDialog.getExistingDirectory(self, "Open Directory", home, # expanduser('./'),
                                                   QFileDialog.ShowDirsOnly)
        #QFileDialog.getExistingDirectory(self, "Choose Directory", home, # expanduser('./'),
        #                                              QFileDialog.DontUseNativeDialog) #
        #slideDir = "D:/WSI/HistoMate_svs/svstest"
        self.lineEdit.setText(slideDir)
        self.treeView_1.setModel(self.model_file_system)
        self.treeView_1.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_1.hideColumn(1)
        self.treeView_1.hideColumn(2)
        self.treeView_1.hideColumn(3)
        print("set slideDir")

        # count the files
        nfiles = len(os.listdir(slideDir))
        self.label_2.setText( "Search :"+str(nfiles) + " files")
        self.label_2.setAlignment(Qt.AlignLeft)

        # load first image
        filepath = glob.glob(os.path.join(slideDir, slide_id))[0]
        filename = os.path.basename(filepath)
        file_png = os.path.join(outputDir, "png", filename.replace("svs", "png"))
        file_csv = os.path.join(outputDir, "csv", filename.replace("svs", "csv"))

        if not os.path.exists(file_png):
            (thumb, meta) = getImageThumbnail(filepath)
            thumb.save(file_png)
            meta.to_csv(file_csv, sep=",")

        png = QPixmap()
        png.load(file_png)
        #png = png.scaledToWidth(511)
        self.label_1.setPixmap(png)

        df = pd.read_csv(file_csv, index_col =0, names=['Name','Value'], header = 0)
        model = pandasModel(df)
        self.tableView.setModel(model)
        self.tableView.horizontalHeader().setSectionResizeMode(1)
        self.tableView.resize(501, 670)

        self.plainTextEdit.appendPlainText("....>> Click one slide file. You can check the image and information.")
        self.plainTextEdit.appendPlainText("....>> And, then press [Segmentation] button ")

    # Btn3: working segmentation :# move to Segmentation_btn3
    def button3Function(self):
        #self.tabWidget.setCurrentIndex(2)
        self.thread.start()
        self.treeView_2.setModel(self.model_file_system)
        self.treeView_2.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_2.hideColumn(1)
        self.treeView_2.hideColumn(2)
        self.treeView_2.hideColumn(3)

        # load first image
        filepath = glob.glob(os.path.join(slideDir, slide_id))[0]
        filename = os.path.basename(filepath)
        file_png = os.path.join(outputDir, "png", filename.replace("svs", "png"))
        mask_png = os.path.join(outputDir,"mask", filename.replace("svs", "jpg"))

        # load png
        png = QPixmap()
        png.load(file_png)
        png = png.scaledToWidth(441)
        self.label_4.setPixmap(png)

        # load mask
        mask = QPixmap(mask_png)
        mask.load(mask_png)
        mask = mask.scaledToWidth(511)
        self.label_3.setPixmap(mask)

        self.plainTextEdit.appendPlainText("....>> Click one slide file. You can explore patches.")
        self.plainTextEdit.appendPlainText("....>> And, then press [Patch] button ")

    # Btn4: working patch :# move to Patching_btn4
    def button4Function(self):
        #self.tabWidget.setCurrentIndex(3)
        #self.thread1.start()
        self.treeView_3.setModel(self.model_file_system)
        self.treeView_3.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_3.hideColumn(1)
        self.treeView_3.hideColumn(2)
        self.treeView_3.hideColumn(3)

        #for file in glob.glob(os.path.join(outputDir,"patch/*/*/*", recursive =True)):
        #    wid = QListWidgetItem()
        #    wid.setIcon(QIcon(file))
        #    self.listWidget.addItem(wid)
          # self.listWidget.setItemWidget(wid, ".")

    # Btn5: working patch :# move to Normalization_btn5
    def button5Function(self):
        #self.tabWidget.setCurrentIndex(4)
        # self.thread1.start()
        self.treeView_4.setModel(self.model_file_system)
        self.treeView_4.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_4.hideColumn(1)
        self.treeView_4.hideColumn(2)
        self.treeView_4.hideColumn(3)

        #for file in glob.glob(os.path.join(outputDir, "/nor/*/*/*", recursive=True)):
        #    wid = QListWidgetItem()
        #    wid.setIcon(QIcon(file))
        #    self.listWidget_2.addItem(wid)
        # self.listWidget.setItemWidget(wid, ".")
        self.plainTextEdit.appendPlainText("....>> Click one slide file. You can expore the normalized patches.")
        self.plainTextEdit.appendPlainText("....>> And, then press [Augmentation] button ")

    # Btn6: working patch :# move to qc_btn6
    def button6Function(self):
        #self.thread3.start()
        self.treeView_6.setModel(self.model_file_system)
        self.treeView_6.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_6.hideColumn(1)
        self.treeView_6.hideColumn(2)
        self.treeView_6.hideColumn(3)

        # load first image
        filepath = glob.glob(os.path.join(slideDir, slide_id))[0]
        filename = os.path.basename(filepath)
        file_png = os.path.join(outputDir, "png", filename.replace("svs", "png"))
        qual_png = os.path.join(outputDir, "qual", "Qual_"+filename.replace("svs", "png"))

        # load png
        png = QPixmap()
        png.load(file_png)
        png = png.scaledToWidth(441)
        self.label_6.setPixmap(png)

        # load qual
        qual = QPixmap()
        qual.load(qual_png)
        qual = qual.scaledToWidth(500)
        self.label_9.setPixmap(qual)

        self.plainTextEdit.appendPlainText("....>> Click one slide file. You can expore the quality of slide.")
        self.plainTextEdit.appendPlainText("....>> And, then press [Segmentation] button ")


    # Btn7: working patch :# move to augmentation_btn7
    def button7Function(self):

        self.treeView_5.setModel(self.model_file_system)
        self.treeView_5.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_5.hideColumn(1)
        self.treeView_5.hideColumn(2)
        self.treeView_5.hideColumn(3)
        #self.tabWidget.setCurrentIndex(3)

        self.plainTextEdit.appendPlainText("....>> Click one slide file. ")
        self.plainTextEdit.appendPlainText("....>> And, then press [Patch QC] button ")

    # Btn8: working patch :# move to qc
    def button8Function(self):

        self.treeView_7.setModel(self.model_file_system)
        self.treeView_7.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_7.hideColumn(1)
        self.treeView_7.hideColumn(2)
        self.treeView_7.hideColumn(3)
        #self.tabWidget.setCurrentIndex(3)
        self.plainTextEdit.appendPlainText("....>> Click one slide file.")
        self.plainTextEdit.appendPlainText("....>> And, then press [Results] button ")

        # Btn8: working patch :# move to summary_btn8
    def button9Function(self):
        self.treeView_8.setModel(self.model_file_system)
        self.treeView_8.setRootIndex(self.model_file_system.index(slideDir))
        self.treeView_8.hideColumn(1)
        self.treeView_8.hideColumn(2)
        self.treeView_8.hideColumn(3)
        # self.tabWidget.setCurrentIndex(3)


    # click the files and loading slide & description
    def item_clikced_1(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        file_png = os.path.join(outputDir, "png", filename.replace("svs", "png"))
        file_csv = os.path.join(outputDir, "csv", filename.replace("svs", "csv"))

        if not os.path.exists(file_png):
            (thumb, meta) = getImageThumbnail(filepath)
            thumb.save(file_png)
            meta.to_csv(file_csv, sep=",")

        # load png
        png = QPixmap()
        png.load(file_png)
        #png =png.scaledToWidth(511)
        self.label_1.setPixmap(png)

        # load description
        df = pd.read_csv(file_csv, index_col =0, names=['Name','Value'], header = 0)
        model = pandasModel(df)
        self.tableView.setModel(model)
        self.tableView.horizontalHeader().setSectionResizeMode(1)
        self.tableView.resize(501, 670)

    # Segmetation : click the files and loading slide & mask
    def item_clikced_2(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        file_png = os.path.join(outputDir, "png", filename.replace("svs", "png"))
        mask_png = os.path.join(outputDir,"mask", filename.replace("svs", "jpg"))

        # load png
        png = QPixmap()
        png.load(file_png)
        self.label_4.setPixmap(png)

        # load mask
        mask = QPixmap(mask_png)
        mask = mask.scaledToWidth(511)
        self.label_3.setPixmap(mask)

    # tiling : click the files and loading slide & mask
    def item_clikced_3(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        #file_png = os.path.join(outputDir, "patch", filename.replace("svs", "png"))
        TileView_png =  os.path.join(outputDir,"patch", "TileView_"+filename.replace("svs", "png"))
        #print(TileView_png)

        # load png
        self.png = QPixmap(TileView_png).scaled(500,500)

        # load png in QGraphicsView
        #self.graphicsView.setScene(QGraphicsScene(self))
        self.graphicsView.scene().addPixmap(self.png)

    def item_clikced_4(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        file = filename.replace(".svs", "")
        print(file)

        for sfile in glob.glob(os.path.join(outputDir, "colNor", file, str(tile_magnification)+"x/*.png"), recursive=True):
            wid = QListWidgetItem()
            wid.setIcon(QIcon(sfile))
            self.listWidget_2.addItem(wid)
            #self.listWidget.setItemWidget(wid, ".")

    # slide click : qc
    def item_clikced_6(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        file_png = os.path.join(outputDir, "png", filename.replace("svs", "png"))
        qual_png = os.path.join(outputDir,"qual", "Qual_"+filename.replace("svs", "png"))

        # load png
        png = QPixmap()
        png.load(file_png)
        self.label_6.setPixmap(png)

        # load qual
        qual = QPixmap()
        qual.load(qual_png)
        qual = qual.scaledToWidth(500)
        self.label_9.setPixmap(qual)

    # slide click : results
    def item_clikced_7(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        #pqc_png = os.path.join(outputDir, "pqc", "Qual_" + filename.replace("svs", "png"))
        ed_png = os.path.join(outputDir, "patchqc", "edge.png")
        sd_png = os.path.join(outputDir, "patchqc", "sd.png")

        # load png
        edpng = QPixmap()
        edpng.load(ed_png)
        edpng = edpng.scaledToWidth(460)
        self.label_11.setPixmap(edpng)


        # load png
        sdpng = QPixmap()
        sdpng.load(sd_png)
        sdpng = sdpng.scaledToWidth(460)
        self.label_12.setPixmap(sdpng)



    def item_clikced_8(self, index):
        filepath = self.model_file_system.filePath(index)
        filename = os.path.basename(filepath)
        file_tbl= os.path.join(outputDir, "summary", filename.replace("svs", "txt"))
        print(file_tbl)
        file_df=pd.read_csv(file_tbl, sep = "\t")
        #df = pd.read_csv(file_csv, index_col=0, names=['Name', 'Value'], header=0)
        sum_df = pandasModel(file_df)
        self.tableView_2.setModel(sum_df)
        self.tableView_2.horizontalHeader().setSectionResizeMode(1)
        self.tableView_2.resize(260, 260)

    def zoom_in(self):
        self.graphicsView.scale(1.2, 1.2)

    def zoom_out(self):
        self.graphicsView.scale(0.8, 0.8)

    def wheelEvent(self, event):
        # 마우스 휠을 스크롤하면 이미지를 확대/축소함
        if event.angleDelta().y() > 0:
            self.graphicsView.scale(1.2, 1.2)
        else:
            self.graphicsView.scale(0.8, 0.8)

    @pyqtSlot(str)
    def on_text_changed(self, str):
        self.str = str
        self.plainTextEdit.appendPlainText(self.str)

    @pyqtSlot(str)
    def set_on_slideDir(self):
        global slideDir
        slideDir =str(self.lineEdit.text())
        #slideDir = "D:/WSI/HistoMate_svs/svs"

    @pyqtSlot(str)
    def set_on_outputDir(self):
        global outputDir
        outputDir =str(self.lineEdit_2.text().replace("Project output path: ", ""))
        #outputDir = "C:/Users/PC/Documents/HistoMate/test"

## run segmenation
class Worker00(QObject):
    intReady = pyqtSignal(str)
    finished = pyqtSignal()

    def run(self):  # A slot takes no params
        str = "....>> Start Segmentation "
        self.intReady.emit(str)
        unet = UNet()
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        net = nn.DataParallel(unet).cuda() if torch.cuda.is_available() else nn.DataParallel(unet)
        checkpoint = torch.load(tsmodel, map_location=device)
        net.load_state_dict(checkpoint['state_dict'])
        net.eval()
        predictor = TilePrediction(patch_size=512,
                                   subdivisions=2.0,
                                   pred_model=net,
                                   batch_size=8,
                                   workers=0)
        slide_list = glob.glob(os.path.join(slideDir, slide_id))
        save_folder = os.path.join(outputDir + "/mask")
        #############################################################################################
        for slide in slide_list:
            basename = os.path.splitext(os.path.basename(slide))[0]
            savename = os.path.join(save_folder, basename + '.jpg')
            print(savename)
            #if not os.path.exists(savename):
            addstr = "....Loading:"+ basename
            self.intReady.emit(addstr)
            print("start")
            #if os.path.exsits(savename):
            #    pass
            #else:
            try:
                print("ok")
                predictor.run(slide, savename)
            except Exception as e:
                print("error")
                   # #self.intReady.emit(e + '\nSkipped slide' +basename)
                   #  continue

        self.intReady.emit("....>> Finish Segmentation")
        self.finished.emit()

# run patching
class Worker01(QObject):
    intReady = pyqtSignal(str)
    finished = pyqtSignal()

    def run(self):
        str = "....>> Start Tiling "
        #print(str)
        self.intReady.emit(str)
        mpp2mag = {.25: 40, .5: 20, 1: 10}
        slide_list = glob.glob(os.path.join(slideDir, slide_id))
        for filename in slide_list:
            basename = os.path.splitext(os.path.basename(filename))[0]
            str = "....Loading:" + basename
            print(basename)
            time.sleep(1)
            self.intReady.emit(str)
            mask_dir = os.path.join(outputDir + "\mask")
            save_dir = os.path.join(outputDir + "\patch")
            print(os.path.join(save_dir, basename))
            #if os.path.exsits(os.path.join(save_dir, basename)):
            #    pass
            #else:
            reader = get_reader_impl(filename)
            ######### sanity check ################
            try:
                slide = reader(filename)
            except IOError:
                print("tiling error")
                #self.plainTextEdit.appendPlainText("skipped {filename} \n error " + str(IOError))
                continue

            maskname = os.path.join(mask_dir, basename + '.jpg')
            if os.path.exists(maskname):
                continue
            #######################################
            save_dir = os.path.join(save_dir, basename, f'{tile_magnification}x')

            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
                wsi_highest_magnification = mpp2mag[.25 * round(float(mpp) / .25)]
                downsample = wsi_highest_magnification / tile_magnification

                process_tiles(filename, tile_size, tile_magnification, stride, downsample, ds_level_0,
                              maskname, mask_magnification, mask_ratio, save_tile, wsi_highest_magnification, save_dir,
                              basename, tile_magnification,
                              n_workers=10)

        self.intReady.emit("....>> Finish Tiling")
        self.finished.emit()

# run normalization
class Worker02(QObject):
    intReady = pyqtSignal(str)
    finished = pyqtSignal()

    def run(self):
        str = "....>> Start Normalization"
        print(str)
        self.intReady.emit(str)
        pool = ThreadPoolExecutor(max_workers=ThreadsAllowed)
        slide_list = glob.glob(os.path.join(slideDir, slide_id))
        Target= "D:\\WSI\\HistoMate_svs\\nor\\TCGA-BR-8078-01Z-00-DX1.8e4a1099-d1c4-46b2-ae3b-5276b93d7003_obj_40x_10x_x_2304_y_9728.png"

        # for slide in slide_list:
        #     basename = os.path.splitext(os.path.basename(slide))[0]
        #     str = "....Loading:" + basename
        #     self.intReady.emit(str)
        #     print(str)
        #     file_list = glob.glob(os.path.join(outputDir, "patch", basename, f'{tile_magnification}x',"*.png") , recursive = True)
        #
        #     for filename in file_list:
        #         file_basename = os.path.splitext(os.path.basename(filename))[0]
        #         savename = filename.replace("patch","colNor")
        #         save_dir = savename.replace(os.path.basename(filename),"")
        #         if not os.path.exists(save_dir):
        #             os.makedirs(save_dir)

                #pool.submit(NormHist, filename,savename, Target)

            #self.intReady.emit(str)
        #pool.shutdown(wait=True)
        self.intReady.emit("....>> Finish Noramlization")
        self.finished.emit()

class Worker03(QObject):
    intReady = pyqtSignal(str)
    finished = pyqtSignal()

    def run(self):
        str = "....>> Start Augmentation"
        #print(str)
        self.intReady.emit(str)
        mpp2mag = {.25: 40, .5: 20, 1: 10}
        slide_list = glob.glob(os.path.join(slideDir, slide_id))
        for filename in slide_list:
            basename = os.path.splitext(os.path.basename(filename))[0]
            str = "....Loading:" + basename
            #print(str)
            time.sleep(2)
            self.intReady.emit(str)

        self.finished.emit()


if __name__ == "__main__" :
    #QApplication : 프로그램을 실행시켜주는 클래스
    app = QApplication(sys.argv)

    #WindowClass의 인스턴스 생성
    myWindow = WindowClass()


    #프로그램 화면을 보여주는 코드
    myWindow.show()


    #프로그램을 이벤트루프로 진입시키는(프로그램을 작동시키는) 코드
    app.exec_()

################################################################################################

